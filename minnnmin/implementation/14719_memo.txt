=============================================================

4 8
3 1 2 3 4 1 1 2

<turn1>
left = 3
tmp = 1, 2 (3보다 작으니 계속 진행)
tmp = 3 인데 left 와 같으니 right = 3
빗물 총량 계산: left 와 right 중 작은 것은 3이므로
사이 값인 1, 2와 3의 차이들을 시그마 하면 ==> 2+1=3
**turn 마다 빗물 총량값 구해서 sum += tmp_sum

이전의 right 가 left 가 됨
<turn2>
left = 3
tmp =4 (left 보다 크거나 같으므로 change)
left = 4
tmp = 1, 1, 2 근데 여기서 끝남 따라서 right 는 = 2
빗물 총량 계산: 계산: left 와 right 중 작은 것은 2이므로
사이 값인 1, 1과 2의 차이들을 시그마 하면 ==> 1+1=2

총 5

=============================================================

3 5
0 0 0 2 0

left = 0
tmp = 0 (사이에 아무것도 없는데 left 와 크거나 같으므로 change)
left = 0
tmp = 0 (사이에 아무것도 없는데 left 와 크거나 같으므로 change)
left = 0
tmp = 2 (사이에 아무것도 없는데 left 와 크거나 같으므로 change)
left = 2
tmp = 0 근데 여기서 끝남 따라서 right = 0
빗물 총량 계산: 계산: left 와 right 중 작은 것은 0이므로
근데 그 사이에 뭐가 없으므로 계산 할 것도 없음 ==> 0

**tmp 들을 리스트로 관리해야겠다. turn 끝나면 clear 하고

=============================================================

4 4
3 0 1 4

left = 3
tmp = 0, 1, 4 근데 여기서 끝남 따라서 right = 4
**끝일 때는 tmp 에 append 하지 말 것
**left 와 크거나 같지만 change 하면 안돼 (이건 끝이 아닐 때만 적용)
빗물 총량 계산: 계산: left 와 right 중 작은 것은 3이므로
사이 값인 0, 1과 3의 차이들을 시그마 하면 ==> 3+2=5

=============================================================

** 왼쪽 최장 길이의 블럭보다 크거나 같은 높이의 블럭이 나오면 끝 (더 있으면 다시 시작)
**
** (사이에 왼쪽과 오른쪽보다 작은 블록 반드시 존재할 때만)
** 왼쪽과 오른쪽의 높이 중 더 작은 것을 기준으로(오른쪽의 기준: 왼쪽보다 크거나 같은 or 벽의 끝)
**
** 연속으로 같은 높이 나오면 제외
**
** 양 끝에 블록 없으면 그냥 흘러가는 것으로 간주 (즉 포함 x)

=============================================================

예외 발견: right < left 인데, between 에 right 보다 큰 블록이 존재할 때

8 9
3 4 5 6 2 3 4 2 1
> 3

8 9
3 4 5 6 2 3 4 2 3
> 4

8 9
3 4 5 6 2 2 2 2 1
> 0

between 을 오른쪽부터 읽으면서 right 보다 크거나 같으면 change

만약 change 가 안 된다면?
거기부터 tmp_left 를 다시 찾아 (right 보다 크거나 같은) 빗물 총량 계산

마지막 거(즉 between[0])가 right 가 되면 여기엔 빗물 안 쌓임