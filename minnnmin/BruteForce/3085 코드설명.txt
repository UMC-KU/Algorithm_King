* 코드 설명

1) original cnt
원래 위치에서 연속한 사탕의 최대 개수를 행과 열 단위로 구함
(여기서 최대 값인 n이 나온다면, 더 이상 진행하지 않고 종료)
==> 한 line씩 검사하므로 시간 복잡도 O(n^2)

2) matrix_search
인접한 사탕의 위치를 교환한 후, 연속한 사탕의 최대 개수를 구하는 함수
세로로 바꾸는 경우 (row만 swap): 바뀐 두 사탕이 각각 속하는 행 두 개와, 바뀐 두 사탕이 함께 속하는 열 하나 ⇒ 총 세 개의 line을 검사
가로로 바꾸는 경우 (col만 swap): 바뀐 두 사탕이 각각 속하는 열 두 개와, 바뀐 두 사탕이 함께 속하는 행 하나 ⇒ 총 세 개의 line을 검사
모든 검사에서는 연속하는 사탕의 최대 개수를 매번 체크해서 최대 값인 경우에는 바로 종료할 수 있도록 함 (복잡도가 커서 의도적으로 탈출구를 많이 만들어 놓음. 앞으로는 복잡도 자체를 줄이는 방식으로 하자)
==> 각 line의 검사에서는 O(n) 소요,
==> 그리고 이 검사를 모든 행과 열에 대해 수행하므로 총 시간 복잡도 O(n^3)

==> 최종 시간 복잡도 O(n^3)

* 편리한 python이지만 무작정 쓰면 안 됨
cols = [[]] * n  ==>  이렇게 빈 리스트를 넣으면 원소인 리스트가 다 복사되므로, 한곳에 값 넣으면 다른 리스트에도 들어간다.
평소에 tmp = [0] * n 자주 써서 습관대로 했다가 오류 떠서 알게 됨

그래서? 이렇게 해야 한다
cols = []
for _ in range(n):
    cols.append([])